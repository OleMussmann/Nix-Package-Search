#!/usr/bin/env bash

VERSION="0.2.0"

HELP="Usage: nps [OPTION]... SEARCH_TERM
Find SEARCH_TERM in available nix packages and sort results by relevance.

List up to three columns, the latter two being optional:
channel.PACKAGE_NAME  [VERSION]  [DESCRIPTION]

Or, with nix experimental features, search the registry flakes instead.
PACKAGE_NAME  [VERSION]  [DESCRIPTION] <- system flake
registry_name#PACKAGE_NAME  [VERSION]  [DESCRIPTION] <- other flakes

Mandatory arguments to long options are mandatory for short options too.

  -c, --color=WHEN               highlight search matches in color,
      --colour=WHEN                WHEN=
                                   {always} always emit color codes
                                    never   never emit color codes
                                    auto    only emit color codes when stdout
                                            is a terminal
  -C, --columns=COLUMNS          choose columns to show,
                                   COLUMNS=
                                   {all}         show all columns
                                    none         show only PACKAGE_NAME
                                    version      also show PACKAGE_VERSION
                                    description  also show PACKAGE_DESCRIPTION
  -e, --experimental=true|false  use experimental nix search {false}
  -f, --flip=true|false          flip the order of sorting {false}
  -h, --help                     display a short help message and exit
  -l, --long-help                display a long help message and exit
  -r, --refresh                  refresh package cache
  -s, --separator=true|false     separate match types with a newline {true}
  -v, --version                  print \`nps\` version and exit"

LONG_HELP="
The \`nps --color=WHEN\` option follows the \`grep\` color option, except that
here the WHEN option is mandatory. Be aware that color codes can trip up
subsequent commands like \`grep\`, if they occur within a match string.

Matches are sorted by type. Show 'exact' matches first, then 'direct' matches,
and finally 'indirect' matches.
  exact     SEARCH_TERM
            registry#SEARCH_TERM
            channel.SEARCH_TERM
  direct    SEARCH_TERM-bar
            registry#SEARCH_TERM-bar
            channel.SEARCH_TERM-bar
  indirect  foo-SEARCH_TERM-bar (or match other columns)
            registry#foo-SEARCH_TERM-bar (or match other columns)
            channel.foo-SEARCH_TERM-bar (or match other columns)

CONFIGURATION
\`nps\` can be configured with environment variables. You can set these in
the configuration file of your shell, e.g. .bashrc/.zshrc .

NIX_PACKAGE_SEARCH_EXPERIMENTAL
  Use the experimental \"nix search\" command.
  It pulls information from the nix flake registries instead of nix channels.
  This is useful if no channels are in use, or channels are not updated
  regularly.
  value: true | false
  default: \"false\"

NIX_PACKAGE_SEARCH_FLIP
  Flip the order of matches? By default most relevant matches appear first.
  Flipping the order makes them appear last and is thus easier to read with
  long output.
  value: true | false
  default: \"false\"

NIX_PACKAGE_SEARCH_SHOW_PACKAGE_VERSION
  Show the VERSION column.
  value: true | false
  default: \"true\"

NIX_PACKAGE_SEARCH_SHOW_PACKAGE_DESCRIPTION
  Show the DESCRIPTION column.
  value: true | false
  default: \"true\"

NIX_PACKAGE_SEARCH_PRINT_SEPARATOR
  Separate matches with a newline?
  value: true | false
  default: \"true\"

NIX_PACKAGE_SEARCH_FOLDER
  In which folder is the cache located?
  value: path
  default: \"${HOME}/.nix-package-search\"

NIX_PACKAGE_SEARCH_EXACT_COLOR
  Color of EXACT matches, match
    SEARCH_TERM
    registry#SEARCH_TERM
    channel.SEARCH_TERM
  value: black, blue, green, red, cyan, magenta, yellow, white
    or true colors, see https://github.com/BurntSushi/ripgrep/blob/master/FAQ.md#how-do-i-configure-ripgreps-colors
  default: \"magenta\"

NIX_PACKAGE_SEARCH_DIRECT_COLOR
  Color of DIRECT matches, match
    SEARCH_TERM-bar
    registry#SEARCH_TERM-bar
    channel.SEARCH_TERM-bar
  value: black, blue, green, red, cyan, magenta, yellow, white
    for advanced color options, see https://github.com/BurntSushi/ripgrep/blob/master/FAQ.md#how-do-i-configure-ripgreps-colors
  default: \"blue\"

NIX_PACKAGE_SEARCH_INDIRECT_COLOR
  Color of INDIRECT matches, match
    foo-SEARCH_TERM-bar (or match other columns)
    registry#foo-SEARCH_TERM-bar (or match other columns)
    channel.foo-SEARCH_TERM-bar (or match other columns)
  value: black, blue, green, red, cyan, magenta, yellow, white
    for advanced color options, see https://github.com/BurntSushi/ripgrep/blob/master/FAQ.md#how-do-i-configure-ripgreps-colors
  default: \"green\"

NIX_PACKAGE_SEARCH_COLOR_MODE
  \`grep\` color mode, show search matches in color.
  value:
    never   Never show color
    always  Always show color
    auto    Only show color if stdout is in terminal, suppress if e.g. piped
  default: auto"

# Exit script on errors.
set -o errexit

# The return value of a pipeline is the value of the last (rightmost) command
# to exit with a non-zero status. Together with `errexit` it means that an
# error within a pipe will exit the script.
set -o pipefail

# Don't overwrite files with `>`.
set -o noclobber

# Fail if trying to use unbound variables.
set -o nounset

# Flip the order of matches?
# value: true | false
FLIP="${NIX_PACKAGE_SEARCH_FLIP:-false}"

# In which folder is the cache?
# value: path
SEARCH_FOLDER="${NIX_PACKAGE_SEARCH_FOLDER:-"${HOME}/.nix-package-search"}"

# Name of the cache file
# value: filename
CACHE_FILE="nps.cache"

# Name of the experimental cache file
# value: filename
EXPERIMENTAL_CACHE_FILE="nps.experimental.cache"

# Name of the experimental log file
# value: filename
EXPERIMENTAL_LOG_FILE="nps.caching.log"

# Use the experimental \"nix search\" command
# Useful if no channels are in use, or channels are not updated regularly
# value: true | false
EXPERIMENTAL="${NIX_PACKAGE_SEARCH_EXPERIMENTAL:-false}"

# Show the PACKAGE_VERSION column
# value: true | false
SHOW_PACKAGE_VERSION="${NIX_PACKAGE_SEARCH_SHOW_PACKAGE_VERSION:-true}"

# Show the PACKAGE_DESCRIPTION column
# value: true | false
SHOW_PACKAGE_DESCRIPTION="${NIX_PACKAGE_SEARCH_SHOW_PACKAGE_DESCRIPTION:-true}"

# Color of EXACT matches, match channel.SEARCH_TERM
# value: black, blue, green, red, cyan, magenta, yellow, white,
#    or true colors, see https://github.com/BurntSushi/ripgrep/blob/master/FAQ.md#how-do-i-configure-ripgreps-colors
EXACT_COLOR="${NIX_PACKAGE_SEARCH_EXACT_COLOR:-magenta}"

# Color of DIRECT matches, match channel.SEARCH_TERM-bar
# value: black, blue, green, red, cyan, magenta, yellow, white,
#    or true colors, see https://github.com/BurntSushi/ripgrep/blob/master/FAQ.md#how-do-i-configure-ripgreps-colors
DIRECT_COLOR="${NIX_PACKAGE_SEARCH_DIRECT_COLOR:-blue}"

# Color of INDIRECT matches, match channel.foo-SEARCH_TERM-bar
# value: black, blue, green, red, cyan, magenta, yellow, white,
#    or true colors, see https://github.com/BurntSushi/ripgrep/blob/master/FAQ.md#how-do-i-configure-ripgreps-colors
INDIRECT_COLOR="${NIX_PACKAGE_SEARCH_INDIRECT_COLOR:-green}"

# `grep` color mode, show search matches in color
# value:
#   never   Never show color
#   always  Always show color
#   auto    Only show color if stdout is in terminal, suppress if e.g. piped
COLOR_MODE="${NIX_PACKAGE_SEARCH_COLOR_MODE:-auto}"

# Separate matches with a newline?
# value: true | false
PRINT_SEPARATOR="${NIX_PACKAGE_SEARCH_PRINT_SEPARATOR:-true}"

# Replace spaces in the description with this character for easier treatment
# of columns. Here we use the \x01 ASCII control character. It's rare enough
# that it would not appear in package descriptions (fingers crossed).
# value: ASCII character, but don't touch this one
SPACE_PLACEHOLDER="\x01"

# Don't refresh by default.
REFRESH=false

# Test if this version of `getopt` supports long options.
# We can cheat our way around `errexit` by using `if`. To access the
# actual exit status, we now need ${PIPESTATUS[0]}.
if getopt --test > /dev/null; then
    :
fi
if [[ ${PIPESTATUS[0]} -ne 4 ]]; then
    echo
    echo "Error: \`nps\` needs advanced \`getopt\` supporting long options."
    exit 1
fi

LONGOPTS=color:,colour:,columns:,experimental:,flip:,help,long-help,refresh,separator:,version
OPTIONS=c:C:e:f:hlrs:v

# Pass arguments only via   -- "$@"   to separate them correctly.
if getopt --options=$OPTIONS --longoptions=$LONGOPTS \
           --name "$0" -- "$@" > /dev/null; then
   PARSED=$(getopt --options=$OPTIONS --longoptions=$LONGOPTS \
           --name "$0" -- "$@")
else
    # If, for example, the return value is 1, then getopt has complained
    # about wrong arguments to stdout
    echo
    echo "$HELP"
    exit 2
fi

# read getoptâ€™s output this way to handle the quoting right:
eval set -- "$PARSED"

# Display help and exit if no command line arguments are given
if [ $# -eq 0 ]; then
    echo "$HELP"
    exit
fi

invalid_option() {
    OPTION_NAME=$1
    SUPPLIED_OPTION_STRING=$2
    VALID_OPTIONS=$3
    echo "Error: invalid $OPTION_NAME \"$SUPPLIED_OPTION_STRING\"." \
        "Must be $VALID_OPTIONS."
    echo
    echo "$HELP"
    exit 1
}

CHANNEL_ERROR_TEXT="
Channel error. Please use the experimental flag \`--experimental true\` to
query registry flakes instead. See \`nps -l\` for extended help on how to set
flags permanently."

channel_error() {
    echo "$CHANNEL_ERROR_TEXT"
    exit 1
}

filter_caches() {
    REGISTRY_NAME="$1"

    # ansifilter  remove ANSI text formatting and color codes
    #
    # sed  filter text stream; take a package entry like
    #          "* legacyPackages.x86_64-linux.AMB-plugins (0.8.1)"
    #          "  A set of ambisonics ladspa plugins"
    #      - ADD_VERSION_IF_MISSING
    #        add "(-)" as version string if none exists
    #      - FILTER_VERSION
    #        remove brackets around version number
    #        (if existing)
    #          "* legacyPackages.x86_64-linux.AMB-plugins 0.8.1"
    #          "  A set of ambisonics ladspa plugins"
    #      - FILTER_PACKAGE_NAME
    #        isolate package name, match
    #          "*[not a '.'].[not a '.'].PACKAGE_NAME VERSION_NUMBER"
    #        and replace it with
    #          "OPTIONAL_REGISTRY_NAME[no space]PACKAGE_NAME VERSION_NUMBER"
    #      - resulting in
    #          "OPTIONAL_REGISTRY_NAME[no space]AMB-plugins 0.8.1"
    #          "A set of ambisonics ladspa plugins"
    #
    # awk  process text stream
    #        -v RS=""  set row separator to empty newline
    #        $1=$1     set first column to first column; I don't know why
    #                    this is necessary, please let me know if you find
    #                    out!
    #        print $0  print all columns in one row
    #
    #        it should now look like:
    #        "OPTIONAL_REGISTRY_NAME[no space]AMB-plugins 0.8.1 A set of ambisonics ladspa plugins"
    #
    # >    and write it to the OUTPUT_FILE

    ADD_VERSION_IF_MISSING="/^*/s/\([^)]\)$/\1 (-)/"
    FILTER_VERSION="/^*/s/(\(.*\))/\1/"
    FILTER_PACKAGE_NAME="s/^\*[^\.]*\.[^\.]*\.\(.* [^ ]*$\)"
    FILTER_PACKAGE_NAME+="/$REGISTRY_NAME\1/"

    ansifilter | \
    sed -e "$ADD_VERSION_IF_MISSING" | \
    sed -e "$FILTER_VERSION" | \
    sed -e "$FILTER_PACKAGE_NAME" | \
    awk -v RS="" '{$1=$1; print $0}'
}

refresh() {
    # Create cache folder, if not exists
    mkdir -p "$SEARCH_FOLDER"

        echo
        echo "[DEBUG] \$SEARCH_FOLDER: $SEARCH_FOLDER"
        echo "[DEBUG] \$CACHE_FILE: $CACHE_FILE"
        echo "[DEBUG] \$EXPERIMENTAL_LOG_FILE: $EXPERIMENTAL_LOG_FILE"
        echo "[DEBUG] \$EXPERIMENTAL_CACHE_FILE: $EXPERIMENTAL_CACHE_FILE"
        echo "[DEBUG] \$EXPERIMENTAL: $EXPERIMENTAL"
        echo

    # Delete scan log file, if exists
    [ -e "$SEARCH_FOLDER/$EXPERIMENTAL_LOG_FILE" ] && \
            rm -r -- "${SEARCH_FOLDER:?}/${EXPERIMENTAL_LOG_FILE:?}"

    # Delete temporary cache folder, if exists
    [ -e "/tmp/nps/" ] && rm -r -- "/tmp/nps/"

    # Re-create temporary cache folder, if not exists
    mkdir -p /tmp/nps/raw_caches

    if [ "$EXPERIMENTAL" == "true" ]; then
        # nix registry list  list all registries (URL shortcuts) present
        #                      on the system
        # rg                 find lines containing "system flake" at the
        #                      beginning, separated by one or more spaces
        # sed                extract registry name
        SYSTEM_FLAKE="$(nix \
            --extra-experimental-features "nix-command flakes" \
            registry list | \
            rg "^system *flake" | \
            sed -e 's/^system *flake:\([^ ]*\) path.*/\1/')"

        echo
        echo "[DEBUG] System flake: $SYSTEM_FLAKE"
        echo

        TEST_STRING="""
* [0;1m[32;1m[0;1mlegacyPackages.x86_64-linux.AMB-plugins[0m (0.8.1)
  [32;1m[0mA set of ambisonics ladspa plugins

* [0;1m[32;1m[0;1mlegacyPackages.x86_64-linux.ArchiSteamFarm[0m (5.4.0.3)

* [0;1m[32;1m[0;1mlegacyPackages.x86_64-linux.AusweisApp2[0m
  [32;1m[0mAuthentication software for the German ID card

"""
        echo "$TEST_STRING" > "/tmp/nps/test_string"

        FILTERED_TEST_STRING="$(filter_caches "" \
                < "/tmp/nps/test_string")"
        echo
        echo "[DEBUG] filtered \$TEST_STRING:"
        echo "$(echo "$FILTERED_TEST_STRING")"
        echo

        echo "Fetch packages from system registry flake..."
        CACHE="$(nix --extra-experimental-features "nix-command flakes" \
                search "$SYSTEM_FLAKE" \
            2>> "$SEARCH_FOLDER/$EXPERIMENTAL_LOG_FILE")"

        [ -e "$SEARCH_FOLDER/$EXPERIMENTAL_LOG_FILE" ] && \
            echo "[DEBUG] head \$SEARCH_FOLDER/\$EXPERIMENTAL_LOG_FILE:" && \
            head "$SEARCH_FOLDER/$EXPERIMENTAL_LOG_FILE" || \
            echo "[DEBUG] no \$SEARCH_FOLDER/\$EXPERIMENTAL_LOG_FILE"

        echo
        echo "[DEBUG] head \$CACHE:"
        echo "$(echo "$CACHE" | head)"
        echo

        echo "$CACHE" > "/tmp/nps/raw_caches/$SYSTEM_FLAKE"

        echo
        echo "[DEBUG] content of /tmp/nps/raw_caches:"
        ls -lah /tmp/nps/raw_caches
        echo

        echo "Filter registry flake"
        # Use _no_ registry name ("") for system flake
        FILTERED_CACHES="$(filter_caches "" \
                < "/tmp/nps/raw_caches/$SYSTEM_FLAKE")"

        echo
        echo "[DEBUG] head \$FILTERED_CACHES:"
        echo "$(echo "$FILTERED_CACHES" | head)"
        echo

        echo "$FILTERED_CACHES" > "/tmp/nps/$EXPERIMENTAL_CACHE_FILE"

        echo
        echo "[DEBUG] content of /tmp/nps/:"
        ls -lah /tmp/nps/
        echo

        echo "Move cache to $SEARCH_FOLDER"
        mv "/tmp/nps/$EXPERIMENTAL_CACHE_FILE" \
                "$SEARCH_FOLDER/$EXPERIMENTAL_CACHE_FILE"
        echo "Done"
        echo
    else
        echo "Fetch packages from channels..."
        # First writing to a tmp file, so the cache is not destroyed
        # if the cache refreshing is interrupted.
        # '--arg overlays "[]"' prevents overlays from being evaluated, since
        # that might crash the query.
        if CACHE="$(nix-env -qaP --description --arg overlays "[]")"; then
            echo "$CACHE" >| "/tmp/nps/$CACHE_FILE"
        else
            # Raise channel error if nix-env -qaP fails.
            channel_error
        fi

        echo
        echo "[DEBUG] head \$CACHE:"
        echo "$(echo "$CACHE" | head)"
        echo

        echo
        echo "[DEBUG] content of /tmp/nps/:"
        ls -lah /tmp/nps/
        echo

        # Raise channel error if cache file is empty.
        if [ -s "/tmp/nps/$CACHE_FILE" ]; then
            # Cache file has content
            echo "Move cache to $SEARCH_FOLDER"
            mv "/tmp/nps/$CACHE_FILE" "$SEARCH_FOLDER/$CACHE_FILE"
            echo "Done"
            echo
        else
            # Cache file is empty
            channel_error
        fi
    fi
}

version() {
    echo "nps (Nix Package Search) version $VERSION - (C) 2022 Ole Mussmann"
    echo "Released under the MIT license."
    exit 0
}

while true; do
    case "$1" in
        -c|--color|--colour)
            # Remove possible leading '=' sign in option.
            COLOR_MODE="${2#=}"
            case "$COLOR_MODE" in
                none|always|auto)
                    :
                    ;;
                *)
                    invalid_option "color mode" "$COLOR_MODE" \
                        "\"none\", \"always\" or \"auto\""
                esac
            shift 2
            ;;
        -C|--columns)
            # Remove possible leading '=' sign in option.
            COLUMNS="${2#=}"
            shift 2
            case "$COLUMNS" in
                all)
                    SHOW_PACKAGE_VERSION="true"
                    SHOW_PACKAGE_DESCRIPTION="true"
                    ;;
                version)
                    SHOW_PACKAGE_VERSION="true"
                    SHOW_PACKAGE_DESCRIPTION="false"
                    ;;
                description)
                    SHOW_PACKAGE_VERSION="false"
                    SHOW_PACKAGE_DESCRIPTION="true"
                    ;;
                none)
                    SHOW_PACKAGE_VERSION="false"
                    SHOW_PACKAGE_DESCRIPTION="false"
                    ;;
                *)
                    invalid_option "colum option" "$COLUMNS" \
                        "\"all\", \"none\", \"version\" or \"description\""
            esac
            ;;
        -e|--experimental)
            # Remove possible leading '=' sign in option.
            EXPERIMENTAL="${2#=}"
            shift 2
            case "$EXPERIMENTAL" in
                true|false)
                    :
                    ;;
                *)
                    invalid_option "experimental option" "$EXPERIMENTAL" \
                        "\"true\" or \"false\""
            esac
            ;;
        -f|--flip)
            # Remove possible leading '=' sign in option.
            FLIP="${2#=}"
            shift 2
            case "$FLIP" in
                true|false)
                    :
                    ;;
                *)
                    invalid_option "flip option" "$FLIP" \
                        "\"true\" or \"false\""
            esac
            ;;
        -h|--help)
            echo "$HELP"
            exit 0
            ;;
        -l|--long-help)
            echo "$HELP"
            echo "$LONG_HELP"
            exit 0
            ;;
        -r|--refresh)
            REFRESH="true"
            shift
            ;;
        -s|--separator)
            # Remove possible leading '=' sign in option.
            PRINT_SEPARATOR="${2#=}"
            shift 2
            case "$PRINT_SEPARATOR" in
                true|false)
                    :
                    ;;
                *)
                    invalid_option "separator option" "$PRINT_SEPARATOR" \
                        "\"true\" or \"false\""
            esac
            ;;
        -v|--version)
            version
            ;;
        --)
            shift
            break
            ;;
        *)
            echo "Programming error"
            exit 3
            ;;
    esac
done

# Handle non-option arguments.
if [[ $# -ne 1 ]]; then

    # Still run refresh, even if there is no search term.
    if [[ "$REFRESH" == "true" ]]; then
        refresh;
        exit 0
    fi

    echo "$0: A single search term is required."
    echo
    echo "$HELP"
    exit 4
else
    SEARCH_TERM=$1
fi

if [ "$EXPERIMENTAL" == "true" ]; then
    CHOSEN_CACHE_FILE="$EXPERIMENTAL_CACHE_FILE"
else
    CHOSEN_CACHE_FILE="$CACHE_FILE"
fi

# Query packages and store them in the cache file if requested,
# or if the cache file does not exist yet.
if [ "$REFRESH" == "true" ] || \
[ ! -f "$SEARCH_FOLDER/$CHOSEN_CACHE_FILE" ]; then
    refresh
fi

VERSION_FILTER=
if [ "$SHOW_PACKAGE_VERSION" == "true" ]; then
    VERSION_FILTER="\"\t\" \$2 "
fi

DESCRIPTION_FILTER=
if [ "$SHOW_PACKAGE_DESCRIPTION" == "true" ]; then
    DESCRIPTION_FILTER="\"\t\" \$3"
fi

AWK_FILTER_STRING="{print \$1 $VERSION_FILTER $DESCRIPTION_FILTER}"

# rg      Find any matches in the cache file.
# sed     Replace spaces in the description column (3rd) with a placeholder.
# awk     Choose column to display.
# column  Align columns with minimum amount of spaces in between.
# sed     Put back spaces.
MATCHES=$(rg -N "$SEARCH_TERM" "$SEARCH_FOLDER/$CHOSEN_CACHE_FILE" |
    sed "s/  */$SPACE_PLACEHOLDER/3g" |
    awk "$AWK_FILTER_STRING" |
    column -t |
    sed "s/$SPACE_PLACEHOLDER/ /g")

# Reverse line order, if FLIP is "true".
if [ "$FLIP" == "true" ]; then
    MATCHES="$(echo "$MATCHES" | tac)"
fi

# Separate matches
if [ "$EXPERIMENTAL" == "true" ]; then
    # Search for foo#SEARCH_TERM ending with an end-of-line char or whitespace,
    # with "foo#" being optional (flake registry name).
    # '|| true' prevents script exit if no matches are found.
    EXACT=$(echo "$MATCHES" | rg "^([^ ]*#)?$SEARCH_TERM($|\s)" || true)
else
    # Search for foo.SEARCH_TERM ending with an end-of-line char or whitespace.
    # '|| true' prevents script exit if no matches are found.
    EXACT=$(echo "$MATCHES" | rg "^[^.]*.$SEARCH_TERM($|\s)" || true)
fi

if [ "$EXPERIMENTAL" == "true" ]; then
    # Search for foo#foo.SEARCH_TERM-bar, but exclude the EXACT match,
    # with "foo#" being optional (flake registry name).
    DIRECT=$(echo "$MATCHES" | rg "^([^ ]*#)?$SEARCH_TERM" |
             rg -v "^([^ ]*#)?$SEARCH_TERM($|\s)" || true)
else
    # Search for foo.SEARCH_TERM-bar, but exclude the EXACT match.
    DIRECT=$(echo "$MATCHES" | rg "^[^.]*.$SEARCH_TERM" |
             rg -v "^[^.]*.$SEARCH_TERM($|\s)" || true)
fi

# All the rest, excluding the previous matches.
if [ "$EXPERIMENTAL" == "true" ]; then
    INDIRECT=$(echo "$MATCHES" | rg -v "^([^ ]*#)?$SEARCH_TERM" || true)
else
    INDIRECT=$(echo "$MATCHES" | rg -v "^[^.]*.$SEARCH_TERM" || true)
fi

if [ "$FLIP" == "true" ]; then
    # Flipped ordering
    if [ "$INDIRECT" ]; then
        # rg  Highlight INDIRECT matches in their own color, but don't throw
        # away lines without match. This works through the "and" operator `|`.
      echo "$INDIRECT" |
          rg --colors="match:fg:$INDIRECT_COLOR" --color="$COLOR_MODE" \
          "$SEARCH_TERM|"
    fi
    if [ "$DIRECT" ]; then
        # Print separator if requested and needed
        if [ "$INDIRECT" ] && [ "$PRINT_SEPARATOR" == "true" ]; then echo; fi

        # rg  Highlight DIRECT matches in their own color, but don't throw
        # away lines without match. This works through the "and" operator `|`.
        echo "$DIRECT" |
            rg --colors="match:fg:$DIRECT_COLOR" --color="$COLOR_MODE" \
            "$SEARCH_TERM|"
    fi
    if [ "$EXACT" ]; then
        # Print separator if requested and needed
        if [[ ( "$INDIRECT"  ||  "$DIRECT" ) && \
        "$PRINT_SEPARATOR" == "true" ]]; then
            echo;
        fi

        # rg  Highlight EXACT matches in their own color.
        echo "$EXACT" |
            rg --colors="match:fg:$EXACT_COLOR" --color="$COLOR_MODE" \
            "$SEARCH_TERM"
    fi
else
    # Normal ordering
    if [ "$EXACT" ]; then
        # rg  Highlight EXACT matches in their own color.
        echo "$EXACT" |
            rg --colors="match:fg:$EXACT_COLOR" --color="$COLOR_MODE" \
            "$SEARCH_TERM"
    fi
    if [ "$DIRECT" ]; then
        # Print separator if requested and needed
        if [ "$EXACT" ] && [ "$PRINT_SEPARATOR" == "true" ]; then echo; fi

        # rg  Highlight DIRECT matches in their own color, but don't throw
        # away lines without match. This works through the "and" operator `|`.
        echo "$DIRECT" |
            rg --colors="match:fg:$DIRECT_COLOR" --color="$COLOR_MODE" \
            "$SEARCH_TERM|"
    fi
    if [ "$INDIRECT" ]; then
        # Print separator if requested and needed
        if [[ ( "$EXACT"  ||  "$DIRECT" ) && "$PRINT_SEPARATOR" == "true" ]];
            then
            echo;
        fi

        # rg  Highlight INDIRECT matches in their own color, but don't throw
        # away lines without match. This works through the "and" operator `|`.
        echo "$INDIRECT" |
            rg --colors="match:fg:$INDIRECT_COLOR" --color="$COLOR_MODE" \
            "$SEARCH_TERM|"
    fi
fi
